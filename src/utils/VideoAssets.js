// Video asset management utility
export const getOptimizedVideoSrc = (baseVideoPath) => {
  // Check device capabilities and connection
  const getDeviceCapabilities = () => {
    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    const isSlowConnection = connection && (
      connection.effectiveType === 'slow-2g' || 
      connection.effectiveType === '2g' ||
      connection.saveData === true
    );
    
    const isMobile = window.innerWidth <= 768;
    const hasHighDPI = window.devicePixelRatio > 1;
    
    return {
      isSlowConnection,
      isMobile,
      hasHighDPI,
      effectiveType: connection?.effectiveType || 'unknown'
    };
  };

  const capabilities = getDeviceCapabilities();
  
  // Define video variants (these would be generated by your compression script)
  const videoVariants = {
    original: baseVideoPath,
    compressed: {
      '1080p': {
        mp4: baseVideoPath.replace('.mp4', '-1080p.mp4'),
        webm: baseVideoPath.replace('.mp4', '-1080p.webm')
      },
      '720p': {
        mp4: baseVideoPath.replace('.mp4', '-720p.mp4'),
        webm: baseVideoPath.replace('.mp4', '-720p.webm')
      },
      '480p': {
        mp4: baseVideoPath.replace('.mp4', '-480p.mp4'),
        webm: baseVideoPath.replace('.mp4', '-480p.webm')
      }
    }
  };

  // Select appropriate quality based on device and connection
  const selectQuality = () => {
    if (capabilities.isSlowConnection) {
      return '480p';
    } else if (capabilities.isMobile && !capabilities.hasHighDPI) {
      return '720p';
    } else {
      return '1080p';
    }
  };

  // Select format based on browser support
  const selectFormat = () => {
    // Check WebP support (more efficient)
    const video = document.createElement('video');
    if (video.canPlayType('video/webm')) {
      return 'webm';
    }
    return 'mp4';
  };

  const quality = selectQuality();
  const format = selectFormat();

  // Return multiple sources for the video element
  return {
    primary: videoVariants.compressed[quality][format],
    fallback: videoVariants.compressed[quality]['mp4'], // MP4 as fallback
    poster: baseVideoPath.replace('.mp4', '-poster.jpg'),
    quality,
    format,
    shouldAutoPlay: !capabilities.isSlowConnection
  };
};

// Preload critical video resources
export const preloadVideo = (videoSrc, poster) => {
  return new Promise((resolve, reject) => {
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'video';
    link.href = videoSrc;
    link.onload = resolve;
    link.onerror = reject;
    document.head.appendChild(link);

    // Also preload poster image
    if (poster) {
      const posterLink = document.createElement('link');
      posterLink.rel = 'preload';
      posterLink.as = 'image';
      posterLink.href = poster;
      document.head.appendChild(posterLink);
    }
  });
};

// Monitor video performance
export const trackVideoPerformance = (videoElement, videoSrc) => {
  if (!videoElement || !('performance' in window)) return;

  const startTime = performance.now();
  
  const handleLoadStart = () => {
    console.log('Video loading started:', videoSrc);
  };

  const handleCanPlay = () => {
    const loadTime = performance.now() - startTime;
    console.log(`Video ready to play in ${loadTime.toFixed(2)}ms`);
    
    // Track with analytics if available
    if (window.gtag) {
      window.gtag('event', 'video_load_time', {
        event_category: 'performance',
        event_label: videoSrc,
        value: Math.round(loadTime)
      });
    }
  };

  const handleError = (error) => {
    console.error('Video loading error:', error);
    
    // Track errors with analytics
    if (window.gtag) {
      window.gtag('event', 'video_error', {
        event_category: 'error',
        event_label: videoSrc
      });
    }
  };

  videoElement.addEventListener('loadstart', handleLoadStart);
  videoElement.addEventListener('canplay', handleCanPlay);
  videoElement.addEventListener('error', handleError);

  // Cleanup function
  return () => {
    videoElement.removeEventListener('loadstart', handleLoadStart);
    videoElement.removeEventListener('canplay', handleCanPlay);
    videoElement.removeEventListener('error', handleError);
  };
};

// Adaptive bitrate streaming simulation
export const createAdaptiveVideoElement = (videoSources, container) => {
  const video = document.createElement('video');
  video.autoplay = false;
  video.muted = true;
  video.loop = true;
  video.playsInline = true;
  video.preload = 'metadata';

  // Add multiple source elements for different qualities
  videoSources.forEach(source => {
    const sourceElement = document.createElement('source');
    sourceElement.src = source.src;
    sourceElement.type = source.type;
    if (source.media) {
      sourceElement.media = source.media; // Media query for responsive videos
    }
    video.appendChild(sourceElement);
  });

  // Monitor connection changes for adaptive streaming
  if ('connection' in navigator) {
    const connection = navigator.connection;
    
    const handleConnectionChange = () => {
      const newCapabilities = getDeviceCapabilities();
      console.log('Connection changed:', newCapabilities.effectiveType);
      
      // You could implement logic here to switch video quality
      // based on connection changes
    };

    connection.addEventListener('change', handleConnectionChange);
  }

  if (container) {
    container.appendChild(video);
  }

  return video;
};

export default {
  getOptimizedVideoSrc,
  preloadVideo,
  trackVideoPerformance,
  createAdaptiveVideoElement
};